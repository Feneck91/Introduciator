#!/usr/bin/env python
# -*- coding: utf-8 -*-

import time
import os
import urllib.parse
import re

import selenium
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait, Select
from selenium.common.exceptions import NoSuchWindowException, NoSuchElementException, TimeoutException
from selenium.webdriver.support import expected_conditions
# import Action chains
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.common.keys import Keys

__all__ = ['ForumManager']

""" Class that manage phpBB's forums.

It contains some functions to be able to make tasks on phpBB's forum.
It should be used with QuickInstall to be able to test phpBB's forum functionalities. 
"""
class ForumManager:
    """ Current password generated by QuickInstall for all users.
    """
    PASSWORD = "123456"

    """ Only one instance for all libraries.
    """
    ROBOT_LIBRARY_SCOPE = 'GLOBAL'

    #===================================================================================================================
    def __init__(self):
        """ Internal initialisations.
        """
        self.main_url = ""
        self.login_name = ""
        self.password = ForumManager.PASSWORD
        self.driver = None

    #===================================================================================================================
    def init(self, main_url):
        """ Open the browser.

        :param main_url: Main URL of the forum to test.
        :return: True if the browser is correctly created, False else.
        """
        # Create session with web browser, select the browser you want
        # self.driver = webdriver.Edge()
        # self.driver = webdriver.Firefox()
        self.main_url = main_url
        print(f"Open Forum on url = '{self.main_url}'...")
        try:
            self.driver = webdriver.Chrome()
        except Exception:
            pass
        if not (self.driver):
            self.driver = webdriver.Chrome(os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', 'drivers', 'chromedriver.exe'))
        self.driver.maximize_window()
        # CLear all cookies else sometimes there are problems with previous cookies
        self.driver.delete_all_cookies()
        # Open web site
        self.driver.get(self.main_url)

        return not (self.driver is None)

    #===================================================================================================================
    def _checkPHPNotice(self):
        """ Check if PHP generate debug notice.

        Throw exception if phpBB notice found!
        """
        noticeItem = self.findXPath("//b[contains(text(), '[phpBB')]")
        if not (noticeItem is None):
            noticeText = self.findXPath("//b[contains(text(), '[phpBB')]/following-sibling::b")
            noticeLine = self.findXPath("//b[contains(text(), '[phpBB')]/following-sibling::b/following-sibling::b")
            noticeLine = "" if noticeLine is None else f" in line {noticeLine.text}"
            text = f"PHPbb server error found = '{noticeText.text} {noticeLine}'!" if noticeText else f"PHPbb server error found!"
            print(text)
            raise Exception(text)

    #===================================================================================================================
    def _navigate_main(self):
        """ Navigate to furum's main page.

        Try to find link from forum's panel, then ACP panel, then main url.
        """

        main_page = self.findXPath("//a[@id='logo']")
        if  main_page:
            main_page.click()
        else:
            main_page = self.findXPath("//a[contains(@href, '/../index.php')]")
            if main_page:
                main_page.click()
            else:
                self.driver.get(self.main_url)

    #===================================================================================================================
    def _wait_until_exists(self, xpath_request, raise_exception, timeout):
        """ Wait until some item exist in page.

        :param xpath_request: XPath request or array or xpath request.
        :param raise_exception If true and element is not found, raise Exception else return None
        :param timeout: Time max to wait in ms.
        :return: The item found, else raise timeout exception.
        """
        objRet = None
        try:
            # wait for typed text animation completed
            wait = WebDriverWait(self.driver, timeout=timeout / 1000)
            if isinstance(xpath_request, list):
                xpath_request = ' | '.join(xpath_request)
            objRet = wait.until(expected_conditions.presence_of_all_elements_located(((By.XPATH, xpath_request))))
        except TimeoutException:
            if raise_exception:
                print(f"wait_until_exists on XPath = {xpath_request} failed!")
                raise

        return objRet

    #===================================================================================================================
    def _wait_until_visible(self, xpath_request, raise_exception, timeout):
        """ Wait until some item exist in page.

        :param xpath_request: XPath request or array or xpath request.
        :param raise_exception If true and element is not found, raise Exception else return None
        :param timeout: Time max to wait in ms.
        :return: The item found, else raise timeout exception.
        """
        objRet = None
        try:
            # wait for typed text animation completed
            wait = WebDriverWait(self.driver, timeout=timeout / 1000)
            if isinstance(xpath_request, list):
                xpath_request = ' | '.join(xpath_request)
            objRet = wait.until(expected_conditions.visibility_of_all_elements_located(((By.XPATH, xpath_request))))
        except TimeoutException:
            if raise_exception:
                print(f"wait_until_exists on XPath = {xpath_request} failed!")
                raise

        return objRet
    #===================================================================================================================
    def generate_QuickInstall(self, profile_name, board_name, board_description, directory_name, is_redirect_to_board, is_populate, is_enable_debug):
        """ Genere a new QuickInstall Board with specific options.

        :param profile_name: The profile name to use to create board.
        :param board_name: The board name (forum's title).
        :param board_description: The board description.
        :param directory_name: Directory name where to install it.
        :param is_redirect_to_board: Shoud redirect to board after install? (True / False).
        :param is_populate: Shoud populate  board? (True / False).
        :param is_enable_debug: Shoud enable debug? (True / False).
        :return True if all working fine else raise exception:
        """
        # Fill Current profile
        select = Select(self.driver.find_element(By.ID, 'qi_profile'))
        select.select_by_visible_text(profile_name)
        # Fill Board Name
        self.driver.find_element(By.ID, "site_name").clear()
        self.driver.find_element(By.ID, "site_name").send_keys(board_name)
        # Fill Board Description
        self.driver.find_element(By.ID, "site_desc").clear()
        self.driver.find_element(By.ID, "site_desc").send_keys(board_description)
        # Fill Board directory
        self.driver.find_element(By.ID, "dbname").clear()
        self.driver.find_element(By.ID, "dbname").send_keys(directory_name)
        # Redirect to new Board
        self.driver.find_element(By.ID, "redirect1" if is_redirect_to_board else "redirect0").click()
        # Populate Board
        self.driver.find_element(By.ID, "populate1" if is_populate else "populate0").click()
        # Enable Debug
        self.driver.find_element(By.ID, "debug1" if is_enable_debug else "debug0").click()
        # Click on button Quick Install
        self.driver.find_element(By.ID, "createboard").click()
        time.sleep(2)

        try:
            # wait for typed text animation completed
            wait = WebDriverWait(self.driver, timeout=300000 / 1000)
            wait.until(expected_conditions.invisibility_of_element_located((By.XPATH, "//div[contains(@class, 'modal-content')]")))
            print("QuickInstall correctly generated.")
        except TimeoutException:
            print("Timed out waiting for QuickInstall generation!")
            raise

        return True

    #===================================================================================================================
    def wait_until_closed(self):
        """ Wait until the browser is closed.

        Loop until the user close the Window.
        """
        if not (self.driver is None):
            while True:
                try:
                    self.driver.title
                except NoSuchWindowException:
                    break
                time.sleep(0.2)

    #===================================================================================================================
    def set_login_name(self, login_name, password=PASSWORD):
        """ Set current username to login.

        All login can use the same password (defined in ForumManager.PASSWORD) if this parameter is ommited.

        :param login_name: User login name to login with.
        :param password: User password to login with. If ignored, take the default one
        """
        self.login_name = login_name
        self.password = password
        print(f"Set login = {self.login_name} / password = {self.password}.")

    #===================================================================================================================
    def findXPath(self, xpath):
        """ Find element by xpath.

        Use Selenium functionnality but don't throw exception if the xpath failed.

        :param xpath: The XPath request.
        :return: The item if found, None else.
        """
        elt = None
        try:
            elt = self.driver.find_element(By.XPATH, xpath)
        except NoSuchElementException:
            pass
        return elt

    #===================================================================================================================
    def _getACP_Tab_X(self, inumber, click_if_exists):
        """ Get the ACP X  Tab.

        The forum must be into ACP panel.

        :return: The customize tab if found, None else.
        """
        itemRet = self.findXPath(f"//li/a[contains(@href, 'i={inumber}')]")
        if itemRet and click_if_exists:
            itemRet.click()
        return itemRet
    #===================================================================================================================
    def getACP_Tab_General(self, click_if_exists = False):
        """ Get the ACP General Tab.

        The forum must be into ACP panel.

        :param click_if_exists: If True and Tab exists, click it before returning.
        :return: The tab if found, None else.
        """
        return self._getACP_Tab_X(1, click_if_exists)

    #===================================================================================================================
    def getACP_Tab_User_And_Group(self, click_if_exists = False):
        """ Get the ACP User And Groups Tab.

        The forum must be into ACP panel.

        :param click_if_exists: If True and Tab exists, click it before returning.
        :return: The tab if found, None else.
        """
        return self._getACP_Tab_X(12, click_if_exists)

    #===================================================================================================================
    def getACP_Tab_Customize(self, click_if_exists = False):
        """ Get the ACP Customize Tab.

        The forum must be into ACP panel.

        :param click_if_exists: If True and Tab exists, click it before returning.
        :return: The tab if found, None else.
        """
        return self._getACP_Tab_X(21, click_if_exists)

    #===================================================================================================================
    def getACP_Tab_Extension(self, click_if_exists = False):
        """ Get the ACP Extension  Tab.

        The forum must be into ACP panel.

        :param click_if_exists: If True and Tab exists, click it before returning.
        :return: The tab if found, None else.
        """
        return self._getACP_Tab_X(32, click_if_exists)

    #===================================================================================================================
    def getLogoutLink(self):
        """ Find the logout item.

        :return: The logout link (a) if found, None else.
        """
        return self.findXPath("//a[contains(@href,'?mode=logout')]")

    #===================================================================================================================
    def getLoggedName(self):
        """ Find the current user logged in.

        :return: The user login if found, None is not found or not logging in.
        """
        retName = None
        # Find logout url, if found it is because a user is logged
        logoutLink = self.getLogoutLink()
        if not(logoutLink is None):
            # find that a user is logged, get the name
            spanObject = self.findXPath("//li[@id='username_logged_in']/*/*/span")
            if spanObject:
                retName = spanObject.text
        return retName

    #===================================================================================================================
    def logout(self):
        # User is not good one, logout
        logoutLink = self.getLogoutLink()
        if not (logoutLink is None):
            print(f"Logout user '{self.getLoggedName()}'")
            self.findXPath("//li[@id='username_logged_in']").click() # Open menu
            self.getLogoutLink().click() # And click on item lougout
            # Wait until login become visible
            self._wait_until_exists("//a[contains(@href,'?mode=login')]", True, 2500)

    #===================================================================================================================
    def login(self):
        """ Login into forum.

        If already logged with correct username, does nothing.
        If logged with another username, logout before login with good username.

        :return: True if correctly logged, False else.
        """
        bRet = None
        trying_number = 10
        while bRet is None and trying_number != 0:
            if not ("mode=login" in self.driver.current_url):
                self._navigate_main()
                loggedName = self.getLoggedName()
                if loggedName:
                    if self.login_name != loggedName:
                        self.logout()
                    else:
                        return True
            # Now login with good username
            loginLink = self.findXPath("//a[contains(@href,'?mode=login')]")
            if loginLink is None:
                # strange it should exists
                raise Exception("Cannot found login link, verify login function!")
            loginLink.click()
            # Now fill login and submit
            self.driver.find_element(By.ID, "username").clear()
            self.driver.find_element(By.ID, "username").send_keys(self.login_name)
            self.driver.find_element(By.ID, "password").clear()
            self.driver.find_element(By.ID, "password").send_keys(self.password)
            self.driver.implicitly_wait(0.5)
            self.findXPath("//input[@name='login']").click()
            self._wait_until_exists(["//li[@id='username_logged_in']/*/*/span", "//fieldset[@class='fields1']/div[@class='error']"], False, 3000)
            if not (self.findXPath("//fieldset[@class='fields1']/div[@class='error']") is None):
                # The submitted form was invalid. Try submitting again.
                print("The submitted form was invalid. Try submitting again. Trying more...")
                trying_number -= 1
                if trying_number < 7:
                    self.driver.get(self.main_url)
                    self.driver.refresh()
                    self._wait_until_exists("//body[@id='phpbb']", False, 10000)
            else:
                bRet = self.getLoggedName() == self.login_name
        print(f"User '{self.login_name}' is logged properly." if bRet else f"User '{self.login_name}  is not logged properly, current logged user is '{self.getLoggedName()}'!")

        return bRet

    #===================================================================================================================
    def login_ACP(self):
        """ Login into forum ACP (administration).

        :return: True if correctly logged, False else.
        """
        # Now login with good username
        self._wait_until_exists("//a[contains(@href,'/adm/index.php')]", True, 2500)
        loginACPLink = self.findXPath("//a[contains(@href,'/adm/index.php')]")
        if loginACPLink is None:
            # strange it should exists
            raise Exception("Cannot found ACP login link, verify loginACP function!")
        loginACPLink.click()
        # Now fill login and submit
        if self.getACP_Tab_Customize() is None:
            # Try to log, never logged on ACP
            self.driver.find_element(By.ID, "username").clear()
            self.driver.find_element(By.ID, "username").send_keys(self.login_name)
            self.findXPath("//input[contains(@id,'password_')]").clear()
            self.findXPath("//input[contains(@id,'password_')]").send_keys(self.password)
            self.driver.implicitly_wait(1)
            self.findXPath("//input[@name='login']").click()

        # Verify the login successed
        return not(self.getACP_Tab_Customize() is None)

    #===================================================================================================================
    def enable_extension(self, extension_name):
        """ Enable extension.

        If the extension is already enabled does nothing and returns True.

        :param extension_name: The extension name like "feneck91/introduciator".
        :return: True if extension is enabled, False else.
        """
        # Go to Customize Tab
        if self.getACP_Tab_Customize(True):
            escaped_extension_name = urllib.parse.quote(extension_name, safe='')
            enableExtensionLink = self.findXPath(f"//tr/td/a[contains(@href, 'action=enable_pre') and contains(@href, 'ext_name={escaped_extension_name}')]")
            if enableExtensionLink:
                # Clic on Enable extension
                enableExtensionLink.click()
                # Clic on Enable button
                enableExtensionButton = self.findXPath("//input[@name='enable']")
                if enableExtensionButton:
                    enableExtensionButton.click()
                    successItem = self.findXPath("//div[@class='successbox']")
                    if successItem:
                        # Go back on extension list
                        self.getACP_Tab_Customize(True)

        self._checkPHPNotice()
        # Return OK if extension can be disabled
        return self.findXPath(f"//tr/td/a[contains(@href, 'action=disable_pre') and contains(@href, 'ext_name={escaped_extension_name}')]")

    #===================================================================================================================
    def clear_all_topics(self, forum_name):
        """ Clear all topic in a forum.

        :param forum_name: The forum's name where all topics should be deleted.
        :return: True if all topic's forum is deleted,
                 Raise exception if some links cannot be found.
        """
        self._navigate_main()
        linkToForum = self.findXPath(f"//a[@class='forumtitle' and text()='{forum_name}']")
        bRet = True
        if linkToForum:
            # Go to forum
            linkToForum.click()
            current_url = self.driver.current_url

            while True:
                first_forum = self._wait_until_exists("//a[@class='topictitle' and contains(@href, '/viewtopic.php')]", False, 1000)
                if first_forum:
                    first_forum[0].click()
                    quick_mode = self.driver.find_element(By.ID, "quickmod")
                    if quick_mode:
                        quick_mode.click()
                        self._wait_until_exists("//a[contains(@href, 'action=delete_topic')]", False, 3000)
                        delete_topic_link = self.findXPath("//a[contains(@href, 'action=delete_topic')]")
                        if delete_topic_link:
                            delete_topic_link.click()
                            self.driver.implicitly_wait(1)
                            self.driver.find_element(By.ID, "delete_permanent").click()
                            self.driver.find_element(By.NAME, "confirm").click()
                            self.driver.get(current_url)
                            self.driver.refresh()
                            self.driver.implicitly_wait(1)
                        else:
                            raise Exception("Delete topic link not found!")
                    else:
                        raise Exception("Delete topic quick mode link not found!")
                else:
                    break
        return bRet

    #===================================================================================================================
    def post_new_topic_into_forum(self, forum_name, post_title, post_content):
        """ Post a  message into a forum.

        :param forum_name: The forum's name where the message should be posted.
        :param post_title: The post title.
        :param post_content: The post content.
        :return: True if it's succeeded, False else.
        """
        self._navigate_main()
        linkToForum = self.findXPath(f"//a[@class='forumtitle' and text()='{forum_name}']")
        bRet = False
        if linkToForum:
            # Go to forum
            linkToForum.click()
            new_topic = self._wait_until_exists( "//a[contains(@href, 'mode=post')]", False, 3000)
            if new_topic:
                new_topic[0].click()
                subject = self._wait_until_exists("//input[@id='subject']", False, 3000)
                if subject:
                    subject[0].clear()
                    subject[0].send_keys(post_title)
                    message = self.driver.find_element(By.ID, "message")
                    message.clear()
                    message.send_keys(post_content)
                    self.driver.find_element(By.XPATH, "//input[@name='post']").click()
                    title_creates = self._wait_until_exists(f"//a[contains(@href, 'viewtopic.php') and text()='{post_title}']", False, 3000)
                    if title_creates:
                        bRet = True

        return bRet

    #===================================================================================================================
    def get_extension_page(self, extension_href_to_find, extension_page_name):
        """ Get a specific page for extension

        :param extension_href_to_find: href to find, to get the extension by HREF.
        :param extension_page_name: Page name to find.
        :return: The item page to clic to go to the page of extension if foud, else None
        """
        item_link_ret = None
        if self.getACP_Tab_Extension(True):
            itemLink = self._wait_until_exists(f"//a[contains(@href, '{extension_href_to_find}') and contains(@href, 'mode={extension_page_name.lower()}')]", False, 1500)
            if itemLink:
                item_link_ret = itemLink[0]

        return item_link_ret

    #===================================================================================================================
    def _configure_forum(self, dict_forums):
        """ Configure a list of forums.
        The configuration is like:

        { "forum"    :   "Your first category",
          "config"   :   { "//textarea[@id='forum_rules']" : "This is the rules of 'Your first category' forum !",
                         },
          "subforums" :  [
                            {
                                "forum" : "Your first forum",
                                "config": { "//input[@type='radio' and @name='enable_quick_reply' and @value='1']" : "click()",
                                            "//textarea[@id='forum_rules']" : "This is the rules of 'Your first forum' !"
                                          }
                            },
                            {
                                "forum" : "Your second forum",
                                "config": { "//input[@type='radio' and @name='enable_quick_reply' and @value='1']" : "click()",
                                            "//textarea[@id='forum_rules']" : "This is the rules of 'Your second forum' !"
                                          }
                            },
                         ]
        }

        :param list_forums: dict that contains configuration of one forum + subforums.
        :return: True if all is good else raise exception.
        """
        if not isinstance(dict_forums, dict):
            raise Exception(f"configure_forum, bad configuration type, should be dict, value = {dict_forums}")
        if not ("forum" in dict_forums):
            raise Exception(f"configure_forum, bad configuration, dict must contains 'forum' key, value = {dict_forums}")
        root_forum_url = self.driver.current_url
        itemforum = self._wait_until_exists(f"//a[contains(@href, 'i=acp_forums') and contains(@href, 'mode=manage') and text()='{dict_forums['forum']}']", True, 3000)
        if itemforum:
            item_a_forum = self.findXPath(f"//a[contains(@href, 'i=acp_forums') and contains(@href, 'mode=manage') and text()='{dict_forums['forum']}']")
            result = re.search("parent_id=([0-9]+)", item_a_forum.get_attribute('href'))
            forum_id = result.group(1)
            if "config" in dict_forums:
                # Configure
                self.driver.find_element(By.XPATH, f"//a[contains(@href, 'i=acp_forums') and contains(@href, 'mode=manage') and contains(@href, 'f={forum_id}&action=edit')]").click()
                self._wait_until_exists("//label[@for='forum_type']", True, 3000)
                # Configure the forum
                if not isinstance(dict_forums['config'], dict):
                    raise Exception(f"configure_forum, bad configuration type for dict_forums['config'], should be dict, value = {dict_forums['config']}")
                for key in dict_forums['config']:
                    value = dict_forums['config'][key]
                    item = self.driver.find_element(By.XPATH, key)  # Raise exception if not found
                    if value == 'click()':
                        item.click()
                    else:
                        item.clear()
                        item.send_keys(value)
                self.driver.find_element(By.XPATH, "//input[@type='submit']").click()  # Submit
                self._wait_until_exists("//div[@class='successbox']", True, 3000)
            if "subforums" in dict_forums:
                # Go to subforums Forum's
                for subforum in dict_forums["subforums"]:
                    self.driver.get(root_forum_url)
                    itemforum = self._wait_until_exists(f"//a[contains(@href, 'i=acp_forums') and contains(@href, 'mode=manage') and text()='{dict_forums['forum']}']", True, 3000)
                    itemforum[0].click()
                    self._configure_forum(subforum)
        else:
            raise Exception(f"configure_forum, bad configuration, forum '{dict_forums['forum']}' not found, value = {dict_forums}")

        return True

    #===================================================================================================================
    def configure_forum(self, list_forums):
        """ Configure a list of forums.
        The configuration is like:

        [
            { "forum"    :   "Your first category",
              "config"   :   { "//textarea[@id='forum_rules']" : "This is the rules of 'Your first category' forum !",
                             },
              "subforums" :  [
                                {
                                    "forum" : "Your first forum",
                                    "config": { "//input[@type='radio' and @name='enable_quick_reply' and @value='1']" : "click()",
                                                "//textarea[@id='forum_rules']" : "This is the rules of 'Your first forum' !"
                                              }
                                },
                                {
                                    "forum" : "Your second forum",
                                    "config": { "//input[@type='radio' and @name='enable_quick_reply' and @value='1']" : "click()",
                                                "//textarea[@id='forum_rules']" : "This is the rules of 'Your second forum' !"
                                              }
                                },
                             ]
            }
        ]

        :param list_forums: List of dict that contains configuration.
        :return: True if all is good, False else.
        """
        ret = True
        try:
            if list_forums is None:
                raise Exception(f"configure_forum, list_forums parameter is None!")
            if not isinstance(list_forums, list):
                raise Exception(f"configure_forum, list_forums parameter should be list, value = {list_forums}")
            if self.getACP_Tab_General(True):
                itemLink = self._wait_until_exists(f"//a[contains(@href, 'i=acp_forums') and contains(@href, 'mode=manage')]", False, 1500) # Manage forum link
                if itemLink:
                    itemLink[0].click()
                    self._wait_until_exists(f"//table[contains(@class, 'forums')]", False, 1500)
                    root_forum_url = self.driver.current_url
                    for info_forums in list_forums:
                        self._configure_forum(info_forums)
            else:
                print("ACP General Tab is not found!")
                ret = False
        except Exception as ex:
            print(f"Exception: '{str(ex)}'!")
            ret = False

        return ret

    #===================================================================================================================
    def configure_Introduciator_extension(self, extension_href_to_find, extension_page_name, is_activate, is_force_user_introduce, is_autorize_deletion_first_post, selected_forum_name, approval_level, use_phpbb_permission, include_groups, seleted_groups_names, ignore_users_list):
        bOk = False
        item_link_ext = self.get_extension_page(extension_href_to_find, extension_page_name)
        # Verify if no PHP problem
        self._checkPHPNotice()

        if item_link_ext:
            item_link_ext.click()
            # Verify if no PHP problem
            self._checkPHPNotice()
            # Set config
            self.driver.find_element(By.ID, "extension_activated" if is_activate else "no_extension_activated").click()
            # Set Force user to introduce
            self.driver.find_element(By.ID, "check_introduction_mandatory_activated" if is_force_user_introduce else "no_check_introduction_mandatory_activated").click()
            # Set Authorize extension to regulate deletion of first post
            self.driver.find_element(By.ID, "check_delete_first_post_activated" if is_autorize_deletion_first_post else "no_check_delete_first_post_activated").click()
            # Select the forum for introduce
            select = Select(self.driver.find_element(By.ID, "forum_choice"))
            for option in select.options:
                if selected_forum_name in option.text:
                    select.select_by_visible_text(option.text)
                    break
            # Select approval level
            if approval_level == 0 or approval_level == 1 or approval_level == 2:
                self.driver.find_element(By.XPATH, f"//input[@name='posting_approval_level' and @value='{approval_level}']").click()
            else:
                raise Exception(f"Unknown approval level='{approval_level}'. Only 0, 1, 2 are allowed!")
            # Set Permsissions
            self.driver.find_element(By.ID, "is_use_permissions" if use_phpbb_permission else "no_is_use_permissions").click()
            if not use_phpbb_permission:
                self.driver.find_element(By.ID, "include_groups" if include_groups else "no_include_groups").click()
                select = Select(self.driver.find_element(By.ID, "groups_choices"))
                select.deselect_all()
                if seleted_groups_names:
                    if not isinstance(seleted_groups_names, list):
                        seleted_groups_names = [seleted_groups_names]
                    for group_value in seleted_groups_names:
                        select.select_by_value(str(group_value))
                # Configure ignored users
                ignored_users_item = self.driver.find_element(By.ID, "ignored_users")
                ignored_users_item.clear()
                if not (ignore_users_list is None):
                    ignored_users_item.send_keys('\n'.join(ignore_users_list))

            # Submit
            self.driver.find_element(By.ID, "submit").click()

            # Verify if no PHP problem
            self._checkPHPNotice()

            # Return True if submit is ok, False else
            errorboxItem = None
            try:
                errorboxItem = self.driver.find_element(By.CLASS_NAME, "errorbox")
                print(f"Initialize Introduciator Extension page {extension_page_name} error!")
            except NoSuchElementException:
                print(f"Initialize Introduciator Extension page {extension_page_name} done.")
            bOk = errorboxItem is None

        return bOk

    def extension_can_be_managed(self, extension_href_to_find, extension_page_name):
        """ Find if an extension can be managed.

        :param extension_href_to_find: HREF to find
        :param extension_page_name: Page extension name
        :return: True if the page extension is accessible, False else.
        """
        item_link_ext = self.get_extension_page(extension_href_to_find, extension_page_name)
        return not(item_link_ext is None)

    def _set_permissions(self, permission_type, permission_tab, permission_name, permission_right):
        """ Set the permissions.

        Set the permission for permission type.
        a_: Administrative
        m_: Global Moderator:
        u_: User permissions:

        :param permission_type: a_ or m_ or u_.
        :param permission_tab: tab000 ... tab00x depending of Admin / Moderator or User permissions.
        :param permission_name: Name of the permission.
        :param permission_right: Right (YES (_y) / NO (_u) / NEVER (_n))
        :return:
        """
        wait = WebDriverWait(self.driver, timeout=10000 / 1000)
        wait.until(expected_conditions.visibility_of_all_elements_located((By.XPATH, "//select[@name='type']")))
        select_type = Select(self.driver.find_element(By.XPATH, "//select[@name='type']"))
        select_type.select_by_value(permission_type)
        # Submit to select this type (button Go)
        self.driver.find_element(By.XPATH, "//input[@class='button2' and @type='submit']").click()
        # Advanced Permissions
        wait.until(expected_conditions.visibility_of_all_elements_located((By.XPATH, "//div[@class='permissions-switch']/a")))
        advanced_permissions = self.driver.find_element(By.XPATH, "//div[@class='permissions-switch']/a")
        advanced_permissions.click()
        # Select Tab
        wait.until(expected_conditions.visibility_of_all_elements_located((By.XPATH, f"//li[@id='{permission_tab}']/a")))
        tab_permissions = self.driver.find_element(By.XPATH, f"//li[@id='{permission_tab}']/a")
        tab_permissions.click()
        # Clic on Yes / No / Never radio
        wait.until(expected_conditions.visibility_of_all_elements_located((By.XPATH, f"//input[contains(@id, '[{permission_name}]{permission_right}')]")))
        right_permissions = self.driver.find_element(By.XPATH, f"//input[contains(@id, '[{permission_name}]{permission_right}')]")
        right_permissions.click()
        time.sleep(0.5) # Sometime indicate forum is invalid
        # Submit Apply permissios (not all), take ONLY the visible submit button
        self.driver.find_element(By.XPATH, "//div[not(contains(@style,'display: none'))]/fieldset[@class='quick']/input[@type='submit' and contains(@name, 'psubmit')]").click()
        # Wait alert appears
        self._wait_until_visible("//div[@id='phpbb_alert']", False, 2000)
        # Wait alert window closed
        wait.until(expected_conditions.invisibility_of_element_located((By.XPATH, "//div[@id='phpbb_alert']")))

    def set_user_permissions(self, user_name, permission_type, permission_tab, permission_name, permission_right):
        """ Set the user permission.

        The name of group (Admin / Robots / etc) could not be used because it is translated. Use group_number.
        1: Guests
        2: Registered users
        4: Global moderators
        5: Administrators
        6: Bots
        7: Newly registered users

        Permission type:
        a_: Administrative
        m_: Global Moderator:
        u_: User permissions:

        :param user_name: User name.
        :param permission_type: a_ or m_ or u_.
        :param permission_tab: tab000 ... tab00x depending of Admin / Moderator or User permissions.
        :param permission_name: Name of the permission.
        :param permission_right: Right (YES (_y) / NO (_u) / NEVER (_n))
        """
        if self.getACP_Tab_User_And_Group(True):
            # Click on User Permission
            self.driver.find_element(By.XPATH, f"//a[contains(@href, 'i=acp_permissions') and contains(@href, 'mode=setting_user_global')]").click()
            self.driver.find_element(By.ID, "username").clear()
            self.driver.find_element(By.ID, "username").send_keys(user_name)
            # Submit
            self.driver.find_element(By.NAME, "submit").click()
            # Set Permissions
            self._set_permissions(permission_type, permission_tab, permission_name, permission_right)
        return True

    def set_group_permissions(self, group_num, permission_type, permission_tab, permission_name, permission_right):
        """ Set the group permission.

        The name of group (Admin / Robots / etc) could not be used because it is translated. Use group_number.
        1: Guests
        2: Registered users
        4: Global moderators
        5: Administrators
        6: Bots
        7: Newly registered users

        Permission type:
        a_: Administrative
        m_: Global Moderator:
        u_: User permissions:

        :param group_num: Number for group name.
        :param permission_type: a_ or m_ or u_.
        :param permission_tab: tab000 ... tab00x depending of Admin / Moderator or User permissions.
        :param permission_name: Name of the permission.
        :param permission_right: Right (YES (_y) / NO (_u) / NEVER (_n))
        """
        if self.getACP_Tab_User_And_Group(True):
            # Click on Group Permission
            self.driver.find_element(By.XPATH, f"//a[contains(@href, 'i=acp_permissions') and contains(@href, 'mode=setting_group_global')]").click()
            select = Select(self.driver.find_element(By.ID, "group"))
            select.select_by_value(group_num)
            # Submit
            self.driver.find_element(By.NAME, "submit").click()
            # Set Permissions
            self._set_permissions(permission_type, permission_tab, permission_name, permission_right)
        return True

if __name__ == '__main__':
    pass